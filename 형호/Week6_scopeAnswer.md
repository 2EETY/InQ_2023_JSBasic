## [김형호] 6주차 과제 제출

---

### 1. Does a function pickup latest changes?

위 코드에서는 `name`변수가 전역변수로 선언되었고, 함수 호출이 뒤에서 이루어졌으니 이미 변수값은 변한 상태로 동작하기 때문에 `Hi Pete`로 나오게 된다.

### 2. Which variables are available?

내부함수(`return function ()`)에서 name변수가 없기 때문에, 스코프체인을 따라서 makeWorker로 올라가게 되고, name이란 변수를 찾았으니, `Pete`를 출력하게 된다.

### 3. counter는 독립적일까요?

저런 함수 방식을 찾아보니 클로저라는 방식이던데, 간단하게 '자신이 생성될 때의 환경(Lexical environment)을 기억하는 함수다' 라고 나와있었다. `makeCounter()`를 호출하면 두개의 렉시컬환경이 만들어진다. 그리고 `counter.[[Environment]]`에 이 위 `s` 렉시컬 환경에 대한 참조가 저장된다. 즉 각 `makeCounter()`를 사용하여 만들때 마다 `makeCounter()`의 렉시컬환경을 참고한 다른 새로운 렉시컬을 만들어 낸다는 것이다.

그후 함수를 실행하게 되면.

1. 중첩함수인 count++에서 count를 찾지만 없고
2. 그 위로 올라가서 `makeCounter()`의 렉시컬환경을 참고한 랙시컬환경에서 count를 찾게 되고
3. count가 0인 걸 발견하게 되고, ++를 한 상태로 0을 리턴하게 된다.
4. 다시 counter를 실행하면, 자신의 렉시컬에서 다시 count를 찾게되고 이 변수는 아까 3에서 ++를 한 1일것이다. 그래서 1에 ++를 하고 1을 리턴하게 된다.
5. 마찬가지로 counter2에서는 위의 1~4과정을 반복하기 때문에 2를 리턴하는것이 아닌 자신의 렉시컬에 저장되어있는 0 을리턴하게 되는것 이다.
